"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const solid_client_authn_core_1 = require("@inrupt/solid-client-authn-core");
const jose_1 = require("jose");
const cross_fetch_1 = require("cross-fetch");
function validateOptions(oidcLoginOptions) {
    return (oidcLoginOptions.refreshToken !== undefined &&
        oidcLoginOptions.client.clientId !== undefined);
}
async function refreshAccess(refreshOptions, dpop, refreshBindingKey, eventEmitter) {
    var _a;
    try {
        let dpopKey;
        if (dpop) {
            dpopKey = refreshBindingKey || (await (0, solid_client_authn_core_1.generateDpopKeyPair)());
            [dpopKey.publicKey.alg] = solid_client_authn_core_1.PREFERRED_SIGNING_ALG;
        }
        const tokens = await refreshOptions.tokenRefresher.refresh(refreshOptions.sessionId, refreshOptions.refreshToken, dpopKey);
        const rotatedRefreshOptions = {
            ...refreshOptions,
            refreshToken: (_a = tokens.refreshToken) !== null && _a !== void 0 ? _a : refreshOptions.refreshToken,
        };
        const authFetch = await (0, solid_client_authn_core_1.buildAuthenticatedFetch)(cross_fetch_1.fetch, tokens.accessToken, {
            dpopKey,
            refreshOptions: rotatedRefreshOptions,
            eventEmitter,
        });
        return Object.assign(tokens, {
            fetch: authFetch,
        });
    }
    catch (e) {
        throw new Error(`Invalid refresh credentials: ${e}`);
    }
}
class RefreshTokenOidcHandler {
    constructor(tokenRefresher, storageUtility) {
        this.tokenRefresher = tokenRefresher;
        this.storageUtility = storageUtility;
    }
    async canHandle(oidcLoginOptions) {
        return validateOptions(oidcLoginOptions);
    }
    async handle(oidcLoginOptions) {
        var _a;
        if (!(await this.canHandle(oidcLoginOptions))) {
            throw new Error(`RefreshTokenOidcHandler cannot handle the provided options, missing one of 'refreshToken', 'clientId' in: ${JSON.stringify(oidcLoginOptions)}`);
        }
        const refreshOptions = {
            refreshToken: oidcLoginOptions.refreshToken,
            sessionId: oidcLoginOptions.sessionId,
            tokenRefresher: this.tokenRefresher,
        };
        await this.storageUtility.setForUser(oidcLoginOptions.sessionId, {
            issuer: oidcLoginOptions.issuer,
            dpop: oidcLoginOptions.dpop ? "true" : "false",
            clientId: oidcLoginOptions.client.clientId,
            clientSecret: oidcLoginOptions.client.clientSecret,
        });
        const publicKey = await this.storageUtility.getForUser(oidcLoginOptions.sessionId, "publicKey");
        const privateKey = await this.storageUtility.getForUser(oidcLoginOptions.sessionId, "privateKey");
        let keyPair;
        if (publicKey !== undefined && privateKey !== undefined) {
            keyPair = {
                publicKey: JSON.parse(publicKey),
                privateKey: (await (0, jose_1.importJWK)(JSON.parse(privateKey), solid_client_authn_core_1.PREFERRED_SIGNING_ALG[0])),
            };
        }
        const accessInfo = await refreshAccess(refreshOptions, oidcLoginOptions.dpop, keyPair);
        const sessionInfo = {
            isLoggedIn: true,
            sessionId: oidcLoginOptions.sessionId,
        };
        if (accessInfo.idToken === undefined) {
            throw new Error(`The Identity Provider [${oidcLoginOptions.issuer}] did not return an ID token on refresh, which prevents us from getting the user's WebID.`);
        }
        sessionInfo.webId = await (0, solid_client_authn_core_1.getWebidFromTokenPayload)(accessInfo.idToken, oidcLoginOptions.issuerConfiguration.jwksUri, oidcLoginOptions.issuer, oidcLoginOptions.client.clientId);
        await (0, solid_client_authn_core_1.saveSessionInfoToStorage)(this.storageUtility, oidcLoginOptions.sessionId, undefined, "true", (_a = accessInfo.refreshToken) !== null && _a !== void 0 ? _a : refreshOptions.refreshToken, undefined, keyPair);
        await this.storageUtility.setForUser(oidcLoginOptions.sessionId, {
            issuer: oidcLoginOptions.issuer,
            dpop: oidcLoginOptions.dpop ? "true" : "false",
            clientId: oidcLoginOptions.client.clientId,
        });
        if (oidcLoginOptions.client.clientSecret) {
            await this.storageUtility.setForUser(oidcLoginOptions.sessionId, {
                clientSecret: oidcLoginOptions.client.clientSecret,
            });
        }
        if (oidcLoginOptions.client.clientName) {
            await this.storageUtility.setForUser(oidcLoginOptions.sessionId, {
                clientName: oidcLoginOptions.client.clientName,
            });
        }
        return Object.assign(sessionInfo, {
            fetch: accessInfo.fetch,
        });
    }
}
exports.default = RefreshTokenOidcHandler;
//# sourceMappingURL=RefreshTokenOidcHandler.js.map