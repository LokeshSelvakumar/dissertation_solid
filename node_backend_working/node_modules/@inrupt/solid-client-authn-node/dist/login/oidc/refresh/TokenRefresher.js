"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const solid_client_authn_core_1 = require("@inrupt/solid-client-authn-core");
const openid_client_1 = require("openid-client");
const IssuerConfigFetcher_1 = require("../IssuerConfigFetcher");
const ClientRegistrar_1 = require("../ClientRegistrar");
const tokenSetToTokenEndpointResponse = (tokenSet, issuerMetadata) => {
    if (tokenSet.access_token === undefined) {
        throw new Error(`The Identity Provider [${issuerMetadata.issuer}] did not return an access token on refresh.`);
    }
    if (tokenSet.token_type !== "Bearer" && tokenSet.token_type !== "DPoP") {
        throw new Error(`The Identity Provider [${issuerMetadata.issuer}] returned an unknown token type: [${tokenSet.token_type}].`);
    }
    return {
        accessToken: tokenSet.access_token,
        tokenType: tokenSet.token_type,
        idToken: tokenSet.id_token,
        refreshToken: tokenSet.refresh_token,
        expiresAt: tokenSet.expires_at,
    };
};
class TokenRefresher {
    constructor(storageUtility, issuerConfigFetcher, clientRegistrar) {
        this.storageUtility = storageUtility;
        this.issuerConfigFetcher = issuerConfigFetcher;
        this.clientRegistrar = clientRegistrar;
    }
    async refresh(sessionId, refreshToken, dpopKey, eventEmitter) {
        const oidcContext = await (0, solid_client_authn_core_1.loadOidcContextFromStorage)(sessionId, this.storageUtility, this.issuerConfigFetcher);
        const issuer = new openid_client_1.Issuer((0, IssuerConfigFetcher_1.configToIssuerMetadata)(oidcContext.issuerConfig));
        const clientInfo = await this.clientRegistrar.getClient({ sessionId }, oidcContext.issuerConfig);
        if (clientInfo.idTokenSignedResponseAlg === undefined) {
            clientInfo.idTokenSignedResponseAlg = (0, ClientRegistrar_1.negotiateClientSigningAlg)(oidcContext.issuerConfig, solid_client_authn_core_1.PREFERRED_SIGNING_ALG);
        }
        const client = new issuer.Client({
            client_id: clientInfo.clientId,
            client_secret: clientInfo.clientSecret,
            token_endpoint_auth_method: clientInfo.clientSecret
                ? "client_secret_basic"
                : "none",
            id_token_signed_response_alg: clientInfo.idTokenSignedResponseAlg,
        });
        if (refreshToken === undefined) {
            throw new Error(`Session [${sessionId}] has no refresh token to allow it to refresh its access token.`);
        }
        if (oidcContext.dpop && dpopKey === undefined) {
            throw new Error(`For session [${sessionId}], the key bound to the DPoP access token must be provided to refresh said access token.`);
        }
        const tokenSet = tokenSetToTokenEndpointResponse(await client.refresh(refreshToken, {
            DPoP: dpopKey ? dpopKey.privateKey : undefined,
        }), issuer.metadata);
        if (tokenSet.refreshToken !== undefined) {
            eventEmitter === null || eventEmitter === void 0 ? void 0 : eventEmitter.emit(solid_client_authn_core_1.EVENTS.NEW_REFRESH_TOKEN, tokenSet.refreshToken);
            await this.storageUtility.setForUser(sessionId, {
                refreshToken: tokenSet.refreshToken,
            });
        }
        return tokenSet;
    }
}
exports.default = TokenRefresher;
//# sourceMappingURL=TokenRefresher.js.map