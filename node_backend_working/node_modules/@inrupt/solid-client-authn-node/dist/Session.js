"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Session = exports.defaultStorage = void 0;
const events_1 = require("events");
const solid_client_authn_core_1 = require("@inrupt/solid-client-authn-core");
const uuid_1 = require("uuid");
const cross_fetch_1 = require("cross-fetch");
const dependencies_1 = require("./dependencies");
exports.defaultStorage = new solid_client_authn_core_1.InMemoryStorage();
class Session extends events_1.EventEmitter {
    constructor(sessionOptions = {}, sessionId) {
        super();
        this.tokenRequestInProgress = false;
        this.lastTimeoutHandle = 0;
        this.login = async (options) => {
            const loginInfo = await this.clientAuthentication.login(this.info.sessionId, {
                ...options,
            }, this);
            if (loginInfo !== undefined) {
                this.info.isLoggedIn = loginInfo.isLoggedIn;
                this.info.sessionId = loginInfo.sessionId;
                this.info.webId = loginInfo.webId;
            }
        };
        this.fetch = async (url, init) => {
            if (!this.info.isLoggedIn) {
                return (0, cross_fetch_1.fetch)(url, init);
            }
            return this.clientAuthentication.fetch(url, init);
        };
        this.logout = async () => this.internalLogout(true);
        this.internalLogout = async (emitEvent) => {
            await this.clientAuthentication.logout(this.info.sessionId);
            clearTimeout(this.lastTimeoutHandle);
            this.info.isLoggedIn = false;
            if (emitEvent) {
                this.emit(solid_client_authn_core_1.EVENTS.LOGOUT);
            }
        };
        this.handleIncomingRedirect = async (url) => {
            let sessionInfo;
            if (this.info.isLoggedIn) {
                sessionInfo = this.info;
            }
            else if (this.tokenRequestInProgress) {
            }
            else {
                try {
                    this.tokenRequestInProgress = true;
                    sessionInfo = await this.clientAuthentication.handleIncomingRedirect(url, this);
                    if (sessionInfo) {
                        this.info.isLoggedIn = sessionInfo.isLoggedIn;
                        this.info.webId = sessionInfo.webId;
                        this.info.sessionId = sessionInfo.sessionId;
                        if (sessionInfo.isLoggedIn) {
                            this.emit(solid_client_authn_core_1.EVENTS.LOGIN);
                        }
                    }
                }
                finally {
                    this.tokenRequestInProgress = false;
                }
            }
            return sessionInfo;
        };
        if (sessionOptions.clientAuthentication) {
            this.clientAuthentication = sessionOptions.clientAuthentication;
        }
        else if (sessionOptions.storage) {
            this.clientAuthentication = (0, dependencies_1.getClientAuthenticationWithDependencies)({
                secureStorage: sessionOptions.storage,
                insecureStorage: sessionOptions.storage,
            });
        }
        else if (sessionOptions.secureStorage && sessionOptions.insecureStorage) {
            this.clientAuthentication = (0, dependencies_1.getClientAuthenticationWithDependencies)({
                secureStorage: sessionOptions.secureStorage,
                insecureStorage: sessionOptions.insecureStorage,
            });
        }
        else {
            this.clientAuthentication = (0, dependencies_1.getClientAuthenticationWithDependencies)({
                secureStorage: exports.defaultStorage,
                insecureStorage: exports.defaultStorage,
            });
        }
        if (sessionOptions.sessionInfo) {
            this.info = {
                sessionId: sessionOptions.sessionInfo.sessionId,
                isLoggedIn: false,
                webId: sessionOptions.sessionInfo.webId,
            };
        }
        else {
            this.info = {
                sessionId: sessionId !== null && sessionId !== void 0 ? sessionId : (0, uuid_1.v4)(),
                isLoggedIn: false,
            };
        }
        if (sessionOptions.onNewRefreshToken !== undefined) {
            this.onNewRefreshToken(sessionOptions.onNewRefreshToken);
        }
        this.on(solid_client_authn_core_1.EVENTS.TIMEOUT_SET, (timeoutHandle) => {
            this.lastTimeoutHandle = timeoutHandle;
        });
        this.on(solid_client_authn_core_1.EVENTS.ERROR, () => this.internalLogout(false));
        this.on(solid_client_authn_core_1.EVENTS.SESSION_EXPIRED, () => this.internalLogout(false));
    }
    onLogin(callback) {
        this.on(solid_client_authn_core_1.EVENTS.LOGIN, callback);
    }
    onLogout(callback) {
        this.on(solid_client_authn_core_1.EVENTS.LOGOUT, callback);
    }
    onNewRefreshToken(callback) {
        this.on(solid_client_authn_core_1.EVENTS.NEW_REFRESH_TOKEN, callback);
    }
}
exports.Session = Session;
//# sourceMappingURL=Session.js.map