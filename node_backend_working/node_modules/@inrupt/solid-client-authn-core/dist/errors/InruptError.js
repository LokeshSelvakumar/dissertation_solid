"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class InruptError extends Error {
    constructor(messageOrIri, messageParams, appendErrorIri = true) {
        super(typeof messageOrIri === "string"
            ? InruptError.substituteParams(messageOrIri, messageParams)
            : InruptError.appendErrorIri(InruptError.lookupErrorIri(messageOrIri, messageParams), messageOrIri, appendErrorIri));
    }
    httpResponse(httpErrorResponse, appendHttpDetails = true) {
        this.message = InruptError.appendHttpResponseDetails(this.message, httpErrorResponse, appendHttpDetails);
        this.httpErrorResponse = httpErrorResponse;
        return this;
    }
    hasHttpResponse() {
        return this.httpErrorResponse !== undefined;
    }
    getHttpResponse() {
        return this.httpErrorResponse;
    }
    getHttpStatusCode() {
        if (this.httpErrorResponse === undefined) {
            throw new InruptError("This InruptError was not provided with a HTTP response - so we can't get its HTTP Status Code.");
        }
        return this.httpErrorResponse.status;
    }
    getHttpStatusText() {
        if (this.httpErrorResponse === undefined) {
            throw new InruptError("This InruptError was not provided with a HTTP response - so we can't get its HTTP Status Text!");
        }
        return this.httpErrorResponse.statusText;
    }
    static determineIfVocabTerm(value) {
        if (value.strict !== undefined) {
            return true;
        }
        return false;
    }
    static lookupErrorIri(iri, messageParams) {
        if (InruptError.determineIfVocabTerm(iri)) {
            const message = messageParams === undefined
                ? iri.message
                : iri.messageParams(...messageParams);
            return message === undefined
                ? `Looked up error message IRI [${iri.value}], but found no message value.`
                : message;
        }
        return `Error message looked up at: [${iri.value}]${messageParams === undefined
            ? ""
            : `, with params [${messageParams.toString()}]`}`;
    }
    static appendHttpResponseDetails(message, response, append) {
        if (append && typeof response !== "undefined") {
            return `${message} HTTP details: status code [${response.status}], status text [${response.statusText}].`;
        }
        return message;
    }
    static appendErrorIri(message, iri, append) {
        return append ? `${message} Error IRI: [${iri.value}].` : message;
    }
    static substituteParams(message, params) {
        let fullMessage = message;
        if (params !== undefined) {
            const paramsRequired = message.split("{{").length - 1;
            if (paramsRequired !== params.length) {
                throw new Error(`Setting parameters on message [${message}], but it requires [${paramsRequired}] params and we received [${params.length}].`);
            }
            for (let i = 0; i < params.length; i += 1) {
                const marker = `{{${i}}}`;
                fullMessage = fullMessage.replace(marker, params[i]);
            }
        }
        return fullMessage;
    }
}
exports.default = InruptError;
//# sourceMappingURL=InruptError.js.map