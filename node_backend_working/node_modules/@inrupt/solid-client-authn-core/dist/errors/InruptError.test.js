"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const globals_1 = require("@jest/globals");
const cross_fetch_1 = require("cross-fetch");
const vocab_inrupt_common_1 = require("@inrupt/vocab-inrupt-common");
const n3_1 = require("n3");
const solid_common_vocab_1 = require("@inrupt/solid-common-vocab");
const InruptError_1 = __importDefault(require("./InruptError"));
(0, globals_1.describe)("InruptError", () => {
    (0, globals_1.describe)("simple error message strings", () => {
        (0, globals_1.it)("treats a message as a simple message", () => {
            const message = "Normal error string...";
            const error = new InruptError_1.default(message);
            (0, globals_1.expect)(error.name).toBe("Error");
            (0, globals_1.expect)(error.toString()).toContain(message);
        });
        (0, globals_1.it)("treats a message as a simple message having params", () => {
            const error = new InruptError_1.default("Normal [{{1}}] error string with [{{0}}]...", ["one", "two"]);
            (0, globals_1.expect)(error.name).toBe("Error");
            (0, globals_1.expect)(error.toString()).toContain("Error: Normal [two] error string with [one]...");
        });
        (0, globals_1.it)("fails if message has incorrect number of params", () => {
            (0, globals_1.expect)(() => new InruptError_1.default("Normal [{{1}}] error string with [{{0}}]...", [
                "one",
                "two",
                "three",
            ])).toThrow("requires [2] params and we received [3]");
        });
    });
    (0, globals_1.describe)("errors that include HTTP response meta-data", () => {
        (0, globals_1.it)("extracts HTTP Response details, but doesn't append details to message", () => {
            const failedResponse = new cross_fetch_1.Response(undefined, {
                status: 404,
            });
            const message = "Normal error string...";
            const error = new InruptError_1.default(message).httpResponse(failedResponse, false);
            (0, globals_1.expect)(error.name).toBe("Error");
            (0, globals_1.expect)(error.hasHttpResponse()).toBe(true);
            (0, globals_1.expect)(error.getHttpStatusCode()).toBe(404);
            (0, globals_1.expect)(error.getHttpStatusText()).toBe("Not Found");
            (0, globals_1.expect)(error.toString()).toContain(message);
            (0, globals_1.expect)(error.toString()).not.toContain("404");
        });
        (0, globals_1.it)("extracts HTTP Response details, and appends details to message", () => {
            const failedResponse = new cross_fetch_1.Response(undefined, {
                status: 404,
            });
            const message = "Normal error string...";
            const error = new InruptError_1.default(message).httpResponse(failedResponse);
            (0, globals_1.expect)(error.name).toBe("Error");
            (0, globals_1.expect)(error.hasHttpResponse()).toBe(true);
            (0, globals_1.expect)(error.getHttpStatusCode()).toBe(404);
            (0, globals_1.expect)(error.getHttpStatusText()).toBe("Not Found");
            (0, globals_1.expect)(error.toString()).toContain(message);
            (0, globals_1.expect)(error.toString()).toContain("404");
        });
        (0, globals_1.it)("throws if no HTTP response", () => {
            const message = "Normal error string...";
            const error = new InruptError_1.default(message);
            (0, globals_1.expect)(error.hasHttpResponse()).toBeFalsy();
            (0, globals_1.expect)(() => error.getHttpStatusCode()).toThrow("can't get its HTTP Status Code.");
            (0, globals_1.expect)(() => error.getHttpStatusText()).toThrow("can't get its HTTP Status Text!");
        });
        (0, globals_1.it)("get HTTP response returns undefined if no HTTP response", () => {
            const message = "Normal error string...";
            const error = new InruptError_1.default(message);
            (0, globals_1.expect)(error.getHttpResponse()).toBeUndefined();
        });
        (0, globals_1.it)("gets the specified HTTP response if it was provided", () => {
            const failedResponse = new cross_fetch_1.Response(undefined, {
                status: 404,
            });
            const message = "Normal error string...";
            const error = new InruptError_1.default(message).httpResponse(failedResponse);
            (0, globals_1.expect)(error.getHttpResponse()).toEqual(failedResponse);
        });
    });
    (0, globals_1.describe)("errors coming from RDF vocabs", () => {
        (0, globals_1.describe)("from remote (non-locally imported) vocabs", () => {
            (0, globals_1.it)("pulls message string from remote RDF vocab", () => {
                const errorIri = new n3_1.NamedNode("https://example.com/vocab#errTest1");
                const error = new InruptError_1.default(errorIri);
                (0, globals_1.expect)(error.name).toBe("Error");
                (0, globals_1.expect)(error.toString()).toContain(errorIri.value);
                (0, globals_1.expect)(error.toString()).toContain("message looked up at");
            });
            (0, globals_1.it)("pulls message string from remote RDF vocab, having params", () => {
                const errorIri = new n3_1.NamedNode("https://example.com/vocab#errTest1");
                const params = ["one", "two"];
                const error = new InruptError_1.default(errorIri, params);
                (0, globals_1.expect)(error.name).toBe("Error");
                (0, globals_1.expect)(error.toString()).toContain(params[0]);
                (0, globals_1.expect)(error.toString()).toContain(params[1]);
                (0, globals_1.expect)(error.toString()).toContain(errorIri.value);
                (0, globals_1.expect)(error.toString()).toContain("message looked up at");
            });
        });
        (0, globals_1.describe)("from locally imported vocabs", () => {
            (0, globals_1.it)("reports failure to find message value on RDF vocab term with no message", () => {
                const errorIri = vocab_inrupt_common_1.INRUPT_TEST.somePredicate;
                const error = new InruptError_1.default(errorIri);
                (0, globals_1.expect)(error.name).toBe("Error");
                (0, globals_1.expect)(error.toString()).toContain(errorIri.value);
                (0, globals_1.expect)(error.toString()).toContain("found no message value");
            });
            (0, globals_1.it)("pulls parameterized message string from local RDF vocab", () => {
                const vocabError = vocab_inrupt_common_1.UI_COMMON.errFileUpload_exceededSizeLimit;
                const params = ["one", "two", "three"];
                const error = new InruptError_1.default(vocabError, params);
                (0, globals_1.expect)(error.name).toBe("Error");
                (0, globals_1.expect)(error.hasHttpResponse()).toBeFalsy();
                (0, globals_1.expect)(error.toString()).toContain(params[0]);
                (0, globals_1.expect)(error.toString()).toContain(params[1]);
                (0, globals_1.expect)(error.toString()).toContain(params[2]);
                (0, globals_1.expect)(error.toString()).toContain(vocabError.value);
                (0, globals_1.expect)(error.toString()).toContain("has size");
                (0, globals_1.expect)(error.toString()).toContain("that exceeds the allowable limit");
            });
            (0, globals_1.it)("pulls localized parameterized message string from local RDF vocab", () => {
                const errorIri = vocab_inrupt_common_1.UI_COMMON.errFileUpload_exceededSizeLimit;
                const params = ["one", "two", "three"];
                const locale = (0, solid_common_vocab_1.getLocalStore)().getItem(solid_common_vocab_1.CONTEXT_KEY_LOCALE);
                try {
                    (0, solid_common_vocab_1.getLocalStore)().setItem(solid_common_vocab_1.CONTEXT_KEY_LOCALE, "es");
                    const error = new InruptError_1.default(errorIri, params);
                    (0, globals_1.expect)(error.name).toBe("Error");
                    (0, globals_1.expect)(error.hasHttpResponse()).toBeFalsy();
                    (0, globals_1.expect)(error.toString()).toContain(params[0]);
                    (0, globals_1.expect)(error.toString()).toContain(params[1]);
                    (0, globals_1.expect)(error.toString()).toContain(params[2]);
                    (0, globals_1.expect)(error.toString()).toContain(errorIri.value);
                    (0, globals_1.expect)(error.toString()).toContain("del archivo");
                    (0, globals_1.expect)(error.toString()).toContain("excede el límite permitido");
                }
                finally {
                    (0, solid_common_vocab_1.getLocalStore)().setItem(solid_common_vocab_1.CONTEXT_KEY_LOCALE, locale);
                }
            });
            (0, globals_1.it)("pulls localized parameterized message string from local RDF vocab with HTTP response and no IRI", () => {
                const errorIri = vocab_inrupt_common_1.UI_COMMON.errFileUpload_exceededSizeLimit;
                const params = ["one", "two", "three"];
                const locale = (0, solid_common_vocab_1.getLocalStore)().getItem(solid_common_vocab_1.CONTEXT_KEY_LOCALE);
                try {
                    (0, solid_common_vocab_1.getLocalStore)().setItem(solid_common_vocab_1.CONTEXT_KEY_LOCALE, "fr");
                    const failedResponse = new cross_fetch_1.Response(undefined, {
                        status: 404,
                    });
                    const error = new InruptError_1.default(errorIri, params, false).httpResponse(failedResponse, true);
                    (0, globals_1.expect)(error.name).toBe("Error");
                    (0, globals_1.expect)(error.hasHttpResponse()).toBe(true);
                    (0, globals_1.expect)(error.getHttpStatusCode()).toBe(404);
                    (0, globals_1.expect)(error.getHttpStatusText()).toBe("Not Found");
                    (0, globals_1.expect)(error.toString()).toContain(params[0]);
                    (0, globals_1.expect)(error.toString()).toContain(params[1]);
                    (0, globals_1.expect)(error.toString()).toContain(params[2]);
                    (0, globals_1.expect)(error.toString()).not.toContain(errorIri.value);
                    (0, globals_1.expect)(error.toString()).toContain("La taille du fichier");
                    (0, globals_1.expect)(error.toString()).toContain("dépasse la limite autorisée");
                }
                finally {
                    (0, solid_common_vocab_1.getLocalStore)().setItem(solid_common_vocab_1.CONTEXT_KEY_LOCALE, locale);
                }
            });
        });
    });
});
//# sourceMappingURL=InruptError.test.js.map